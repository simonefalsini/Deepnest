================================================================================
CRITICAL SEGMENTATION FAULT INVESTIGATION SUMMARY
================================================================================

PROBLEM:
--------
Application crashes with segmentation fault when nesting is run a second time.

ROOT CAUSE:
-----------
Unexecuted lambda tasks from the parallel processor's boost::asio queue
execute AFTER the old engine is destroyed, accessing dangling references.

CRASH SEQUENCE:
---------------
1. First run: NestingEngine#1 created with ParallelProcessor#1
2. During step(): Tasks enqueued with [&population, &worker, ...] captures
3. User clicks Stop: engine_->stop() called, but queue NOT drained
4. Second run: DeepNestSolver::start() destroys old engine
5. CRASH: Old queued task executes with dangling reference to destroyed population

CRITICAL BUGS IDENTIFIED:
-------------------------

BUG #1: Queue Not Flushed (CRITICAL)
File: /home/user/Deepnest/deepnest-cpp/src/parallel/ParallelProcessor.cpp:36-53
Issue: ioContext_.stop() leaves tasks in queue
Fix: Add while(ioContext_.poll() > 0) before threads_.join_all()

BUG #2: Lambda Captures References (CRITICAL)
File: /home/user/Deepnest/deepnest-cpp/src/parallel/ParallelProcessor.cpp:114-148
Issue: [&population, &worker, ...] becomes dangling if destroyed before execution
Fix: Capture by value or use 'this' with getter methods

BUG #3: No Stopped Check in enqueue() (HIGH)
File: /home/user/Deepnest/deepnest-cpp/include/deepnest/parallel/ParallelProcessor.h:158-175
Issue: Posting to stopped io_context causes undefined behavior
Fix: Check if (stopped_) before boost::asio::post()

BUG #4: ParallelProcessor Not Reset (MEDIUM)
File: /home/user/Deepnest/deepnest-cpp/src/engine/NestingEngine.cpp:30-50
Issue: geneticAlgorithm_.reset() called but parallelProcessor_ not reset
Fix: Add parallelProcessor_.reset() in initialize()

BUG #5: Engine Not Destroyed (MEDIUM)
File: /home/user/Deepnest/deepnest-cpp/src/DeepNestSolver.cpp:107-110
Issue: clear() doesn't destroy engine, leaving old engine in memory
Fix: Add engine_.reset() in clear()

MEMORY MANAGEMENT ISSUES:
------------------------
- Pointers not set to nullptr after delete ✓ (using unique_ptr helps)
- Threads not properly joined ✗ (threads exit loop before tasks complete)
- ioContext run() called after stop ✓ (stopped_ flag prevents this)
- Vectors not cleared ✓ (being cleared)
- Circular reference issues: Lambda captures create object lifetime issue

IMMEDIATE IMPACT:
-----------------
CRITICAL: Application WILL crash on second nesting run
SCOPE: Affects any workflow that runs nesting > once without restarting app
WORKAROUND: None (requires code changes)

FILES NEEDING FIXES:
--------------------
1. /home/user/Deepnest/deepnest-cpp/src/parallel/ParallelProcessor.cpp
2. /home/user/Deepnest/deepnest-cpp/include/deepnest/parallel/ParallelProcessor.h
3. /home/user/Deepnest/deepnest-cpp/src/engine/NestingEngine.cpp
4. /home/user/Deepnest/deepnest-cpp/src/DeepNestSolver.cpp

DETAILED DOCUMENTATION:
-----------------------
See SEGFAULT_ANALYSIS.md for comprehensive analysis
See FIXES_REQUIRED.md for exact code changes

TESTING AFTER FIXES:
--------------------
1. Compile and build project
2. Run single nesting pass (should work)
3. Run second nesting pass immediately (THIS WAS CRASHING)
4. Run rapid start/stop cycles 5 times
5. Check with valgrind for memory leaks

ESTIMATED EFFORT:
-----------------
Implementation: 30-45 minutes (5 fixes, some require refactoring)
Testing: 15-20 minutes
Total: 1 hour

PRIORITY: CRITICAL - MUST FIX BEFORE RELEASE

================================================================================
